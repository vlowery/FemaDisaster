---
title: "Data Visualization from Scratch"
author: "NYC Data Science Academy"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introduction 

+ NYC's Department of Health and Mental Hygiene (DOHMH) conducts unannounced inspections of restaurants at least once a year to check food handling, food temperature, personal hygiene, and vermin control. Since 2010, NYC restaurants have to prominently post their Grade (e.g. A/B/C) which empowers diners with decision-making information and incentivizes establishments to improve their hygiene.

+ Download the csv file from [here](https://nycopendata.socrata.com/Health/DOHMH-New-York-City-Restaurant-Inspection-Results/xx67-kt59) and rename it to `data.csv`. Move the file to the same directory of your markdown file and use relative path to read it.

+ After you finish the lab, please push your rmarkdown file (**w/o data**) to the corresponding folder under the homework repository.


## 1. Data Preprocessing

### 1.1 Load libraries
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
```

### 1.2 Load dataset
```{r load_data, cache=TRUE, warning=FALSE, message=FALSE}
raw.df <- readr::read_csv("./data.csv")
```

### 1.3 Clean your data
1. Convert all the column names to lower cases and rename the   cuisine description  column to  cuisine ,   inspection date` to `inspection.date`.
2. Convert the `inspection.date` column from character to date format.
3. If we want to perform analysis for each month, then the date column would be pretty annoying because you have different date for each month. Mutate a new column called `month` that extract the month from `inspection.date` and convert it to numeric. For example, 03/24/2016 -> 03
4. We have scores for some of the observations but their grades are missing. Impute the missing values in grade column with the following rules:
    + 0 <= score < 14: A
    + 14 <= score < 28: B
    + score >= 28: C
    + You can ignore the other grades
5. Rename the description from the action column to something short so it won't blow up your graph.
    + "Violations were cited in the following area(s)." => "violations"
    + "Establishment Closed by DOHMH.  Violations were cited in the following area(s) and those requiring immediate action were addressed." => "closed"
    + "Establishment re-closed by DOHMH" => "reclosed"
    + "No violations were recorded at the time of this inspection." => "no violations"
    + "Establishment re-opened by DOHMH" => "reopened"
    + Hint: `gsub()` function might be helpful. The function takes regular expression as the `pattern` parameter, which means `()` is treated as a special character. You might want to set `fixed=TRUE` in the `gsub()` function to leave the pattern as it is.
    + **reclosed** means they failed the second time during the same inspection cycle and **reopened** means they passed.
6. We want to filter out missing values to make our life easier for further analysis.
    + Filter out missing values from the `boro` column.
    + Filter out missing values and negative values from the `score` column.
    + Filter out any `inspection date` that doesn't make any sense.
7. Select the following columns from `raw.df`: `camis`, `boro`, `cuisine`, `inspection.date`, `action`, `score`, `grade`, `month`
8. Return only the unqiue inspections from the previous step and save it as a new data frame called `inspections`. The reason is one inspection might have multiple observations with different violation code but their actions are the same, so we count them as one.


```{r preprocessing, cache=TRUE}
# 1. Convert all the column names to lower cases and rename the columns that have empty space.
names(raw.df) <- tolower(names(raw.df))
raw.df <- rename(raw.df, cuisine = `cuisine description`) #can be done all in one rename
raw.df <- rename(raw.df, inspection.date = `inspection date`)

# 2. Convert the inspection.date column from character to date format.
raw.df <- raw.df %>% mutate(inspection.date = as.Date(inspection.date, "%m/%d/%Y"))

# 3. Extract the month from the inspection.date column.
raw.df <- raw.df %>% mutate(month=as.numeric(format(inspection.date, "%m"))) # or with lubridate, month = month(inspection.date)

# 4. Impute the missing values for the 'grade' column
raw.df <- raw.df %>% mutate(grade = ifelse(0 < score & score < 14 , 'A',
                                      ifelse(score < 28, 'B', 'C')))


# 5. Rename the description from the action column to something short so it won't blow up your graph.
# ifelse to avoid 5 gsub find and sub, or convert to factor and rename factor
raw.df <- mutate(raw.df, action = gsub(pattern = "Violations were cited in the following area(s).", replacement = "violations", x = action, ignore.case = F, fixed = T)) %>%
  mutate(action = gsub(pattern = "No violations were recorded at the time of this inspection.", replacement = "no violations", x = action, ignore.case = F)) %>%
  mutate(action = gsub(pattern = "Establishment re-opened by DOHMH", replacement = "reopened", x = action, ignore.case = F)) %>%
  mutate(action = gsub(pattern = "Establishment Closed by DOHMH.  Violations were cited in the following area(s) and those requiring immediate action were addressed.", replacement = "closed", x = action, ignore.case = F, fixed = T)) %>%
  mutate(action = gsub(pattern = "Establishment re-closed by DOHMH", replacement = "reclosed", x = action, ignore.case = F))


# 6. We want to filter out missing values to make our lives easier for further analysis.
raw.df <- filter(raw.df,
            boro != '0' & #Eliminate remaining rows with boro == 'Missing'; confirmed that none are in NYC
            inspection.date > '1900-01-01' & #Eliminate rows where the restaurant hasn't been inspected yet
            !is.na(score) & #Eliminate rows without a score
            score >= 0 #Eliminate rows with a negative score
)

# 7. Select the following columns from raw.df: camis, boro, cuisine, inspection.date, action, score, grade, month
raw.df <- select(raw.df, camis, boro, cuisine, inspection.date, action, score, grade, month)

# 8. Unique inspections
inspections = unique(raw.df)
```


## 2. Data Visualization
### Example questions we want to answer from this dataset

- How do a restaurant's location and type of cuisine affect its inspection results?
- Do restaurants in Manhattan have better scores than those of restaurants in Queens or the Bronx?
- Are Manhattan restaurants cleaner than those in Queens or the Bronx? 
- Do restaurants of your favorite cuisine perform better or worse in health inspections than the rest of the restaurants?

### 2.1 Inspection Grade vs Borough
- What is your conclusion?
```{r}
#Bar plot: Restaurants by borough and grade

ggplot(data=inspections) +
  geom_bar(aes(x=boro,fill=grade), position='dodge') +
  labs(title='Restaurants by borough and latest grade',
       x='Borough',
       y='Restaurants') +
  scale_fill_brewer(palette='Set1') +
  theme_bw() +
  theme(legend.key=element_blank())
```

### 2.2 Inspection Grade vs Cuisine
- There are too many cuisine in the dataset and it will make the plot hard to read. Let's just focus on the top 20 cuisines.
- What is your conclusion?
```{r}
#Bar plot: Restaurants by cuisine and grade

cuisine_flitered <- inspections %>%
  group_by(cuisine) %>%
  summarise(count=n()) %>%
  top_n(20, count)

inspectionsFiltered = semi_join(inspections, cuisine_flitered, by = 'cuisine')

ggplot(data=inspectionsFiltered) +
  geom_bar(aes(x=reorder(cuisine, cuisine, function(x) length(x)), fill=grade), position='dodge') +
  labs(title='Restaurants by cuisine and grade',
       x='Cuisine',
       y='Restaurants') +
  scale_fill_brewer(palette='Set1') +
  coord_flip() + 
  theme_bw() +
  theme(legend.key=element_blank())
```

#### 2.3 Scores vs. Borough
- Since grades couldn't differentiate boroughs, let's plot restaurants by scores instead and used a density plot to account for the disparity in number of restaurants by borough.
- What is your conclusion?
```{r}
#Density plot: Restaurants by score and borough

ggplot(data=inspections, aes (x=score)) + 
  stat_density(aes(color=boro), geom="line",position="identity") + 
  coord_cartesian(xlim=c(0,40)) +
  labs(title='Density of restaurants by latest score and borough', 
       x='Score', 
       y='Restaurant density') + 
  scale_y_continuous(breaks=seq(0,0.14,0.02),
                     labels = scales::percent) +
  scale_colour_brewer(palette='Set1') +
  theme_bw() +
  theme(legend.key=element_blank()) +
  geom_vline(xintercept = c(14,28), colour='grey') +
  annotate("text", x = c(6,20,35), y = 0.11, label = c('A','B','C'), size=6) +
  annotate("rect", xmin = 0, xmax = 14, ymin = 0, ymax = 0.13, alpha = .2, fill='darkred') +
  annotate("rect", xmin = 14, xmax = 28, ymin = 0, ymax = 0.13, alpha = .2, fill='darkblue') +
  annotate("rect", xmin = 28, xmax = 60, ymin = 0, ymax = 0.13, alpha = .2, fill='darkgreen')
```

### What about inspection closures?
- Scores don't tie directly to restaurant closures (e.g. public health hazard)

### 2.4 Closures vs. Borough

- Reclosed means they failed the second time during the same inspection cycle.
- Defined the following ratios:
    - Inspection closure ratio for each borough: % of inspections that lead to the restaurant being closed (including closed and reclosed)
    - Repeat closure ratio for each borough: % of restaurants that were closed more than once for different inspection cycles (just count the number of closed)
- What is your conclusion?
```{r}
# It could be either a barplot with two different ratios for each borough or a scatterplot with two ratios as x and y axises.

#Total counts of inspections that led to closures by borough
inspClosByBoro = inspections %>%
  group_by(boro) %>%
  summarise(closures = sum(action == 'closed' | action == 'reclosed'),
            inspection = n(),
            ratio = closures / inspection)

#Restaurants that were closed at least once (closures, not reclosures as part of the same inspection cycle)
reclosedByBoro =  inspections %>%
  filter(action == 'closed') %>%
  group_by(camis, boro) %>%
  summarize(count = n()) %>%
  group_by(boro) %>%
  summarize(total_closed = n(),
            closed_more_than_once = sum(count>1),
            ratio = closed_more_than_once / total_closed)

#Closure and repeat closure combined - by borough
boroClosureRatios = left_join(inspClosByBoro, reclosedByBoro, by = 'boro') %>%
  rename(inspRatio = ratio.x, recloRatio = ratio.y)

ggplot(data = boroClosureRatios, aes(x=inspRatio, y=recloRatio)) +
  geom_point(aes(colour = boro), size = 3) +
  labs(title='Inspection closure and repeat closure ratios by borough',
       x='Inspection closure ratio',
       y='Repeat closure ratio') +
  scale_x_continuous(limits = c(0.01,0.025),
                     labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_colour_brewer(palette = 'Set1') +
  theme_bw() +
  theme(legend.position='none') +
  geom_text(aes(label=boro),
            check_overlap=TRUE,
            size=3,
            hjust = 0,
            nudge_x = 0.0003)
```

### 2.5 Closures vs. Cuisine and Borough
- Finally, what if we combined both dimensions of location and cuisine? Intuitively, certain cuisines could fare better or worse in health inspections depending on the neighborhood. Used faceted bar plots of inspection closure ratios by borough with the top 20 cuisine types.

- What is your conclusion?
```{r}
# Facect barplots of insepction closure ratios by borough with top 20 cuisine types.

#Ratio of inspection closures by top 20 cuisine and boro
inspClosByCuisineBoro = inspectionsFiltered %>%
  group_by(cuisine, boro) %>%
  summarise(closures = sum(action == 'closed' | action == 'reclosed'),
            inspections = n(),
            ratio = closures / inspections)

#Faceted bar plot: Inspection closure ratio by top 20 cuisine and borough
ggplot(data=inspClosByCuisineBoro, aes(x=cuisine, y=ratio)) + 
  geom_bar(stat='identity', aes(fill=boro)) + 
  facet_grid(. ~ boro) +
  labs(title='Inspection closure ratio by top 20 cuisine and borough', x='Top 20 cuisine', y='Inspection closure ratio') +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette = 'Set1') +
  theme_bw() +
  theme(legend.key=element_blank(), legend.position="bottom") +
  coord_flip()
```


### 2.6 Trend of score by month
- What is your conclusion?
```{r}
# Find the trend of average scores by month and borough. Graph your result

trendScoreMonth = inspections %>%
  group_by(month, boro) %>%
  summarise(avg = mean(score))

ggplot(data=trendScoreMonth, aes(x = month, y = avg)) + 
  geom_freqpoly(stat='identity', aes(color=boro)) +
  labs(title='Average score by month and borough',
       x='Month',
       y='Average score') +
  coord_cartesian(xlim = c(1,12), ylim = c(13,18)) +
  scale_x_continuous(breaks = 1:12, 
                     labels=c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")) +
  scale_color_brewer(palette='Set1') +
  theme_bw() +
  theme(legend.key=element_blank())

```


### 2.7 Trend of inspection closure ratio by month
- What is your conclusion?
```{r}
# Find the trend of the inspection closure ratio by month and borough. Graph your result.

trendClosures = inspections %>%
  group_by(month, boro) %>%
  summarise(closures = sum(action == 'closed' | action == 'reclosed'),
            inspection = n(),
            ratio = closures / inspection)

ggplot(data=trendClosures, aes(x=month, y=ratio)) +
  geom_freqpoly(stat='identity', aes(color=boro)) +
  labs(title='Inspection closure ratio by month and borough',
       x='Month',
       y='Inspection closure ratio') +
  coord_cartesian(xlim = c(1,12)) +
  scale_x_continuous(breaks = 1:12,
                     labels=c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")) +
  scale_y_continuous(limits=c(0.005,0.045),
                     breaks=seq(0,0.035,0.005),
                     labels=scales::percent) +
  scale_color_brewer(palette='Set1') +
  theme_bw() +
  theme(legend.key=element_blank())
```

